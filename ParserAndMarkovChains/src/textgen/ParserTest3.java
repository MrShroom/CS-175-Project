package textgen;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import edu.stanford.nlp.ling.TaggedWord;

public class ParserTest3 {

	public static void main(String [] args){
		
		//Generate taggedword list from a file.
		List<TaggedWord> words = ParserUtil.getFlatTaggedWordListPath("res/hemingway");
		
		//Create markov chains for different ngrams. These chains handle the pos tags.
		List<MarkovChain<String>> posChains = new ArrayList<MarkovChain<String>>();
		for(int i = 1 ;i <= 3; ++i){
			posChains.add(NgramUtil.genPosMarkovNgram(words, i));
		}
		
		
		//Create hashmaps of postag to markovchain. each hashmap corrisponds to a different ngram size.
		List<HashMap<String,MarkovChain<String>>> wordChains = new ArrayList<HashMap<String,MarkovChain<String>>>();
		for(int i = 1; i <= 3; ++i){
			wordChains.add(NgramUtil.genMarkovWordGramMap(words,i));
		}
		
		//poslist is an array of pos-tags, generated by the pos markov chains.
		List<String> poslist = new ArrayList<String>();
		//chose an arbitrary starting tag. A real system for this needs to be setup.
		poslist.add("JJ");
		//Generate 600 pos tags.
		for(int i = 0; i < 600; ++i){
			//Use the highest n ngram chain to pick pos.
			for(int j = posChains.size()-1; j >= 0; --j){
				if(poslist.size()<j+1)
					continue;
				String ngram = NgramUtil.toNgram(poslist, j+1);
				if(posChains.get(j).HasNext(ngram)){
					System.out.println("PosGram Size: " + (j+1));
					poslist.add(posChains.get(j).getNext(ngram));
					break;
				}
			}
		}
		
		//Now create the array of actual words.
		List<String> wlist = new ArrayList<String>();
		//start with arbitrary starting word. "known" is tagged as JJ.
		wlist.add("known");
		for(int i = 0; i < poslist.size()-1; ++i){
			//Get the part of speech tag we're trying to match.
			String nextPOS = poslist.get(i+1);
			//Choose largest n ngram markov chain to generate the next word.
			for(int j = wordChains.size()-1; j >= 0; --j){
				//First few words are trivially impossible for large ngram chains.
				if(wlist.size()<j+1)
					continue;
				//Larger ngram maps might not have a markov chain for that pos tag.
				if(!wordChains.get(j).containsKey(nextPOS))
					continue;
				//Calculate ngram to find the successor of.
				String ngram = NgramUtil.toNgram(wlist, j+1);
				//Generate word from the markov chain corrisponding
				//to the desired part of speech.
				if(wordChains.get(j).get(nextPOS).HasNext(ngram)){
					System.out.println("WordGram Size: "+(j+1));
					wlist.add(wordChains.get(j).get(nextPOS).getNext(ngram));
					break;
				}
			}
		}
		
		
		//Print out the wlist array as a paragraph.
		System.out.print(wlist.get(0));
		for(int i = 1; i < wlist.size(); ++i){
			if(!wlist.get(i).matches("[\\.,\\?;]"))
				System.out.print(" ");
			System.out.print(wlist.get(i));
		}
		
		
		
	}
	
}
