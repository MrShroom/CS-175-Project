package textgen.tests;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import MySQLToBagOfWords.BagOfWordUtilites;
import edu.stanford.nlp.ling.TaggedWord;
import textgen.NgramUtil;
import textgen.ParserUtil;
import textgen.datastructs.MarkovChain;

public class ParserTest3 {

	public static void main(String [] args){
		
		//Create markov chains for different ngrams. These chains handle the pos tags.
		List<MarkovChain<String>> posChains = new ArrayList<MarkovChain<String>>();
		for(int i = 1 ;i <= 5; ++i){
			posChains.add(new MarkovChain<String>());
		}
		
		//Create hashmaps of postag to markovchain. each hashmap corrisponds to a different ngram size.
		List<HashMap<String,MarkovChain<String>>> wordChains = new ArrayList<HashMap<String,MarkovChain<String>>>();
		for(int i = 1; i <= 5; ++i){
			wordChains.add(new HashMap<String,MarkovChain<String>>());
		}
		
		//Generate taggedword list from a file.
		//List<TaggedWord> words = ParserUtil.getFlatTaggedWordListPath("res/hemingway");
		Set<String> categories = new HashSet<String>();
		categories.add("Restaurants");
		Set<Integer> stars = new HashSet<Integer>();
		stars.add(5);
		Set<String> listOfReview = BagOfWordUtilites.getSetOfReviews(categories, stars, 2000);
		
		for(String review : listOfReview)
		{
			List<TaggedWord> words = new ArrayList<TaggedWord> ();
			words = ParserUtil.getFlatTaggedWordListString(review);
			System.out.println("----->"+ words.get(0));	
			for(int i = 1; i <= 3;++i){
				NgramUtil.teachMarkovWordGramMap(wordChains.get(i-1), words, i);
			}
			for(int i = 1; i <= 5; ++i){
				
				NgramUtil.teachPosMarkovNgram(posChains.get(i-1), words, i);
			}
		}
		
		
		
		//poslist is an array of pos-tags, generated by the pos markov chains.
		List<String> poslist = new ArrayList<String>();
		//chose an arbitrary starting tag. A real system for this needs to be setup.
		poslist.add("VBD");
		//Generate 600 pos tags.
		for(int i = 0; i < 600; ++i){
			//Use the highest n ngram chain to pick pos.
			for(int j = posChains.size()-1; j >= 0; --j){
				if(poslist.size()<j+1)
					continue;
				String ngram = NgramUtil.toNgram(poslist, j+1);
				if(posChains.get(j).HasNext(ngram)){
					System.out.println("PosGram Size: " + (j+1));
					poslist.add(posChains.get(j).GetNext(ngram));
					break;
				}
			}
		}
		
		//Now create the array of actual words.
		List<String> wlist = new ArrayList<String>();
		//start with arbitrary starting word. "known" is tagged as JJ.
		wlist.add("Had");
		for(int i = 0; i < poslist.size()-1; ++i){
			//Get the part of speech tag we're trying to match.
			String nextPOS = poslist.get(i+1);
			//Choose largest n ngram markov chain to generate the next word.
			for(int j = wordChains.size()-1; j >= 0; --j){
				//First few words are trivially impossible for large ngram chains.
				if(wlist.size()<j+1)
					continue;
				//Larger ngram maps might not have a markov chain for that pos tag.
				if(!wordChains.get(j).containsKey(nextPOS))
					continue;
				//Calculate ngram to find the successor of.
				String ngram = NgramUtil.toNgram(wlist, j+1);
				//Generate word from the markov chain corrisponding
				//to the desired part of speech.
				if(wordChains.get(j).get(nextPOS).HasNext(ngram)){
					System.out.println("WordGram Size: "+(j+1));
					wlist.add(wordChains.get(j).get(nextPOS).GetNext(ngram));
					break;
				}
			}
		}
		
		
		//Print out the wlist array as a paragraph.
		System.out.print(wlist.get(0));
		for(int i = 1; i < wlist.size(); ++i){
			if(!wlist.get(i).matches("[\\.,\\?;]"))
				System.out.print(" ");
			System.out.print(wlist.get(i));
		}
		
		
		
	}

}
